# 闭包

## 闭包相关概念

1. 闭包的官方概念：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是表达式的一部分。
	- 闭包是指有权访问另一个函数作用域中的变量（参数）的函数
	- 闭包就是能读取其他函数内部变量（参数）的函数
	- 闭包可以理解成定义在一个函数内部的函数
	- 函数就是闭包
2. 个人解读：当一个函数能够记住并访问到其所在的词法作用域及作用域链，特别强调是在其定义的作用域外进行的访问，此时该函数和其上层执行上下文共同构成闭包。
	- 闭包一定是函数对象
	- 函数内保持对上层作用域的引用 
	- 闭包和词法作用域、作用域链、垃圾回收机制等息息相关
	- 当函数在其定义的作用域外进行访问时，才产生闭包
	- 闭包是由该函数和其上层执行上下文共同构成

## 闭包相关知识
1. 变量
	- 变量无非就是两种：全局变量和局部变量
	- JavaScript语言中，函数内部可以直接读取全局变量，在函数外部无法直接读取函数内的局部变量
2. 作用域：
	
	- 程序设计中作用域的概念：通常来说，一段程序代码中所用到的名字并不总是有效／可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。
3. 词法作用域：也叫静态作用域，它的作用域是指在词法分析阶段就确定了，不会改变。
4. 动态作用域，是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。
5. 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。javascript 使用的是词法作用域 （静态）在解析阶段就确定了
6. 作用域链：
	- 本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。
	- 每个执行环境都有一个与之关联的变量对象，执行环境中定义的所有变量和函数都保存在这个变量对象中。
	- 全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境的变量对象是window对象。
	- 当JavaScript解释器初始化执行代码时，首先默认进入全局执行环境。
	- 局部执行环境的变量对象，则只在函数执行的过程中存在。
	- 当函数被调用的时候，会创建一个特殊的对象–活动对象。
	- 活动对象之后会作为局部执行环境的变量对象来使用。
`// 作用域链：本质上是一个指针列表[变量对象的引用地址，变量对象的引用地址]
        // 变量对象 -> 执行上下文的一部分
        // 执行上下文（执行环境） 
        // 全局执行环境  - 变量对象 -> window
        // 局部执行环境  - 活动对象 === 变量对象
     
        var a = 123;
        function test(x,y){
            console.log(a);
            var b = 456;
            function fn(){
                console.log(x + y);
                console.log(c);
            }
            fn();
        }
        test();

        // 代码模拟
        // 1.创建全局执行上下文对象
        globalEC = {
            'scope-chain' : [window],
            'VO' : { // 变量对象
                a : undefined, // -> 123
                test : function test(x,y){}
            },
            this : window
        }

        // 2.逐行执行代码
        a = 123;
        test(7);
        // 3.创建test函数执行上下文对象
        testEC = { // 函数执行上下文
            'scope-chain' : [testEC.AO,globalEC.VO],
            'AO' : { // 活动对象
                arguments : {
                    0 : 7,
                    length : 1
                },
                x : 7,
                y : undefined,
                b : undefined, // -> 456
                fn : function fn(){}
            },
            this : window
        }
        // 4.test函数内部执行
        console.log(a); // 123
        b = 456;
        fn();
        // 5.创建fn函数的执行上下文对象
        fnEC = {
            'scope-chain' : [fnEC.AO,testEC.AO,globalEC.VO],
            'AO' : {
                arguments : {
                    length : 0
                },
                this : window
            }
        }
        // 6.fn函数内部执行
        console.log(x + y); // NaN
        console.log(c); // c is not defined`
7. 垃圾回收机制：各大浏览器通常采用的垃圾回收有两种方法：标记清除、引用计数
	- 标记清除：当变量进入执行环境时，将这个变量标记为“进入环境”。当变量离开执行环境时，则将其标记为“离开环境”，就销毁回收内存。
	- 引用计数：跟踪记录每个值被引用的次数，当引用次数变成0时，就销毁回收内存

## 闭包的应用
1. 在函数外读取函数内部的变量
2. 让局部变量的值能够被保存下来
3. 将模块的公有属性和方法暴露出来


## 注意：闭包会使得函数中的变量被保存在内存中，增加内存消耗，不能滥用闭包，否则会造成网页的性能问题，在低版本IE中还可能导致内存泄露。